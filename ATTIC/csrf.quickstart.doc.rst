.. _user_csrf_protection:

Cross-Site Request Forgery (CSRF) protection
--------------------------------------------

Cross-Site Request Forgery (CSRF) is a type of attack where a user is logged
into site A, then visits site B which tells the browser "Do this bad thing
on site A". Without CSRF protection, site A actually performs the "bad
thing".

For more in depth info on CSRF, take a look at:
https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

Because it is *very, very important* to protect your API's against this kind
of attack, Flask-Micron comes bundled with a CSRF protection plugin. This
plugin is enabled by default. This is something to beware of when trying to
talk to the web service from a client. You will have to play by the rules:

  1. All responses (also error responses) generated by Flask-Micron include
     a CSRF token in the HTTP header ``X-Micron-CSRF-Token``.

  2. Clients must take this token from the response header and include it
     in the HTTP header ``X-Micron-CSRF-Token`` on their next request.
     When no token is sent to Flask-Micron or an invalid token is sent,
     the request will be denied with an error.

I can hear you think: "But how do I get a token for my first request then?"
For that purpose, Flask-Micron automatically sets up a ``/ping`` method,
which does not check for a valid CSRF token. So the simple handshake from
above can be bootstrapped by issuing a ``/ping`` request from the client,
to get hold of a first token.

If you want to implement your own bootstrapping function, or if you want to
disable the CSRF protection module (which I advise strongly against), you
can make use of the ``csrf`` plugin configuration option::

    app = Flask(__name__)
    app.secret_key = "Key to make SecureCookieSession work for CSRF"
    micron = Micron(app, csrf=False)

    @micron.method()
    def hello_world():
        return 'Hello, World!'

In this example, the ``hello_world()`` function is not CSRF-protected, because
the CSRF protection module has been fully disabled in the ``Micron``
constructor. Be careful when using this method. Other functions in this API
will also be unprotected!

To disable CSRF protection for a single function, you can make use of the
``@micron.method()`` decorator configuration::

    app = Flask(__name__)
    app.secret_key = "Key to make SecureCookieSession work for CSRF"
    micron = Micron(app)

    @micron.method(csrf=False)
    def give_me_a_token():
        return 'You will find your token in the headers'

    @micron.method()
    def hello_world():
        return 'Hello, World!'

In this example, the API provides the unprotected function
``give_me_a_token()``, that could be used (just like ``/ping``) for
bootstrapping the CSRF handshake cycle.

Below, some example code that shows how one could obtain and use a
CSRF token using the `Requests`_ Python library::

    import requests

    # Start a Session, to make the Flask session cookie work.
    s = requests.Session()

    # POST to /ping and fetch a fresh CSRF token from the headers.
    r = s.post('http://localhost:5000/ping')
    csrf_token = r.headers['X-Micron-CSRF-Token']

    # POST to /hello_world, including the CSRF token in the headers.
    headers = {'X-Micron-CSRF-Token': csrf_token}
    r = s.post('http://localhost:5000/hello_world', headers=headers)

    print(r.text)

The output of this script is::

    "Hello, World!"
