A simple POST-only JSON protocol, based on conventions
------------------------------------------------------

An important reason for using a simple protocol, is to make it feasible and
easy to write a generic client library to talk to a Micron service.

POST-only was chosen to make sure that data is never embedded in GET URLs
and to make attacks like CSRF one jumpable hoop less convenient for attackers.

For a full description of the protocol see the file 'PROTOCOL'.

Business logic is separated from request handling
-------------------------------------------------

Micron allows you to let the implementation of a function and tests for that
function be totally unaware of the surrounding application and framework
(except maybe for request handling, for which Micron dictates the use of
error classes that are derived from MicronError).

This means that you could start by writing some business logic function:

  class NoSuchEntityError(MicronClientError):
      """A requested entity was not found in the database."""

  def get_product(id):
      data = ProductDB().get_product(id)
      if not data:
          raise NoSuchEntityError('product, id = %s' % id)
      return data

After which tests can be written for it:

  def test_GivenExistingId_GetProductReturnsProductData(self):
      ProductDB().add_product(id='CSWP', name='Chicken Soup with Pees')
      data = get_product('CSWP')
      self.assertEquals({id: 'CSWP', name='Chicken Soup with Pees'})

  def test_GivenNonExistingId_GetProductRaisesException(self):
      with self.assertRaises(NoSuchEntityError):
          get_product('NONO')

Up to this point, there is no need to already hook the function into Flask
by making it a Micron method. This can be done after the previous business
logic-level steps. Here an example where CSRF checking is enabled and
some authorization plugin must check if the user has the role of
'product_reader'.

  @micron.method(auth_role='product_reader', csrf=True)
  def get_product(id):
      ...
      ...

I normally will refrain from writing full stack unit test (e.g. using Flask
testing utilities like app_context() and test_client()) to check for example
if the method is actually protected with the role 'product_reader'. In my
opinion, you are integration testing the framework at that point, and not
your code.

For one scenario, this is not that big of an issue, but when you're
developing using TDD (Test Driven Development), the number of scenarios and
tests might grow fast and having to write full stack tests everytime will
grow boring pretty fast.

Once you have tested the functionality of the auth_role configuration option
in other tests (the tests for the auth plugin that is used), I see the
definition of the @micron.method as configuration / declaration and not als
code. At that point, the auth_role is a proven configuration building block.

Of course, feel free to write integration tests if you find them valuable,
these were just my $0.02.


Built-in normalization of request data
--------------------------------------

In the request data, leading and trailing whitespace are automatically removed
from string values. String values that are empty strings are normalized to
None. This is the setup as enabled by default.

When you do not want to make use of these normalization features, then it is
possible to configure different behaviour in the Micron() object or the
@micron.method decorator. Take a look at the normalize_input plugin
documentation.


Built-in CSRF protection
------------------------

When not protected, CSRF (Cross Site Request Forgery) attacks are very
dangerous for a website / service. A malicous person can trick a trusted
browser into performing operations on your website / service, on behalf of a
user, without the user even being aware of it.

Flask-Micron comes bundled with a CSRF protection plugin and protection is
enabled by default for all requests. It is possible to disable protection on
a per method base, but note that I strongly advice against that.

Take a look at the PROTOCOL document and the CSRF plugin documentation for
information on how a client must behave, in order to keep the CSRF checking
happy.
